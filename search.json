[{"title":"MyBatis之@Param注解详解","url":"/2025/04/26/MyBatis-Param-Annotation/","content":"1.认识@Param注解  @Param注解通常用于 MyBatis（一个流行的 Java 持久层框架）中，用于给 SQL 映射方法中的参数起别名，便于在 XML 映射文件中引用。这是 MyBatis 中的一种常见用法，尤其在方法参数较多时，使用 @Param 可以明确标识参数的名称。\n2.@param作用我们先来看这样一个情景：数据库中有一张学生表(id,name,age,height,birth,sex),我们想要通过name和sex字段来查询某条记录，方法定义如下:\n\n\n此时测试程序出现报错:org.apache.ibatis.binding.BindingException: Parameter ‘name’ not found. Available parameters are [arg1, arg0, param1, param2]\n\n原因是在 MyBatis 中，当你使用 XML 映射文件进行 SQL 映射时，SQL 中的参数通常通过 #{} 方式引用。但在多个参数的情况下，MyBatis 通过参数的位置来引用它们，比如第一个参数为  arg0(param1),第二个参数为arg1(param2)……以此类推。\n因此我们将mapper映射文件中#{}的位置改成下图所示，就可以正常查询到了。\n\n\n而@Param注解允许我们明确标识参数的名称。\n\n\n在使用了@Param后，最开始的问题也不存在了，可以正常查询到结果。\n3.为什么要使用@Param注解？1.命名清晰：当方法有多个参数时，使用 @Param 为每个参数命名可以清晰地知道每个参数的含义，避免参数混乱。\n2.避免位置依赖：如果不使用 @Param，MyBatis 会根据参数的位置来推断它们的名称。但如果方法参数顺序发生变化，SQL 映射可能会出错。通过 @Param 可以避免这种问题，因为每个参数都显式地指定了名称。\n3.提高可读性和维护性：在 SQL 映射文件中，可以通过清晰的参数名称提高代码的可读性，使得后续的维护更加方便。\n4.@Param注解原理下面我们深入了解一下@Param底层原理:\n①首先我们在获取了mapper接口代理对象并执行方法时，我们首先进入MapperProxy对象中执行invoke方法\n\n其中的核心代码是：\nreturn Object.class.equals(method.getDeclaringClass()) ? method.invoke(this, args) :this.cachedInvoker(method).invoke(proxy, method, args, this.sqlSession);\n\n即判断调用的方法(指getStudentByNameAndSex)是否是Object类中定义的方法(显然不是)，因此会执行第二个分支方法this.cachedInvoker(method).invoke(proxy, method, args, this.sqlSession);\n②：进入第二个分支又会调用MapperProxy类中的invoke方法,其中执行了一个名为execute的方法\n\n③进入execute方法后，在内部判断了我们最开始调用方法对应的sql语句类型（图中为SELECT）\n进入SELECT判断分支后,在分支内部对调用方法的返回值进行了多种情况的判断:\n在图中的方法最后后进入else分支，在其中执行关键代码:\nparam = this.method.convertArgsToSqlCommandParam(args);\n\n\n\n在这句代码中，args就是我们执行方法时传递的参数值；\n\n方法名convertArgsToSqlCommandParam，直译过来就是将参数转换为SQL命令参数\n因此@Param的作用将在这个方法中进行体现\n\n④在convertArgsToSqlCommandParam中，又调用了getNamedParams(args)方法，\nargs依然是我们传递的参数值\n\n⑤getNamedParams方法中，会判断我们是否使用了@Param注解\n\n由于我们使用了注解，因此会进入else分支，定义一个Map&lt;String, Object&gt;类型的param变量，然后对本类中一个名为names的SortedMap&lt;Integer, String&gt;集合的每一个entry进行遍历，这个集合的作用是存放我们@Param指定的参数名，key为序号(从0开始),value为参数名。\n\n\n其中关键的代码：\nparam.put(entry.getValue(), args[(Integer)entry.getKey()]);entry.getValue()是@Param中指定的参数名(name,sex), entry.getKey()是参数名对应的序号(0,1)，args[(Integer)entry.getKey()]就是取出args中我们传递的参数值。\n\n也就是说程序会依次取出@Param注解中指定的值作为key，对应的参数值作为value存储在param中。\n遍历完成后，param集合的存储结果如下：\n\n对比一下不使用@Param注解时，param集合的存储结果就是这样的\n\n可以发现我们通过@Param自定义的参数名覆盖了原本的arg0,arg1…但是param1，param2仍然可以使用。\n最后getNamedParams方法会将param返回，这样@Param注解也就发挥了他的作用。\n5.总结​       @Param 注解在 MyBatis 中的作用是帮助映射方法的多个参数，使它们能够在 SQL 语句中有明确的名字。对于没有 @Param 的方法参数，MyBatis 会将它们打包成一个 Map 来传递给 SQL 语句。使用 @Param 注解能够确保每个参数都有唯一的标识，并避免多参数情况下的冲突问题。\n​       在程序调用时执行到目标方法后，底层会建立一个SortedMap&lt;Integer, String&gt;类型的集合，称names，其中key是序号(从0开始),value是@Param中指定的参数名;然后遍历names，将names中所有的参数名作为key，传递的参数值作为value存储到一个Map&lt;String, Object&gt; 中，称param，最后将param返回。\n\n","categories":["学习记录","MyBatis"]}]